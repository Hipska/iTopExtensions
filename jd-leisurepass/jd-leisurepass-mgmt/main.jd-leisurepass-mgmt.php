<?php

// PHP Data Model definition file

// WARNING - WARNING - WARNING
// DO NOT EDIT THIS FILE (unless you know what you are doing)
//
// If you use supply a datamodel.xxxx.xml file with your module
// the this file WILL BE overwritten by the compilation of the
// module (during the setup) if the datamodel.xxxx.xml file
// contains the definition of new classes or menus.
//
// The recommended way to define new classes (for iTop 2.0) is via the XML definition.
// This file remains in the module's template only for the cases where there is:
// - either no new class or menu defined in the XML file
// - or no XML file at all supplied by the module

class izLeisureTime implements iApplicationObjectExtension {
	
	 
	
	
	// public function OnUpdate( $oObject, $aChanges ) is AFTER updating
	
		/**
	 *	Invoked to determine whether an object can be written to the database 
	 *	
	 *	The GUI calls this verb and reports any issue.
	 *	Anyhow, this API can be called in other contexts such as the CSV import tool.
	 * 
	 * @param DBObject $oObject The target object
	 * @return string[] A list of errors message. An error message is made of one line and it can be displayed to the end-user.
	 */	
	public function OnCheckToWrite($oObject) {
		
		if($oObject instanceof LeisurePass) {
			 		
			// For easy reference
			$oPass = $oObject;
			
			// No check required on creation.
			if((Int)$oPass->GetKey( ) > 1) {
			 
				$sOQL = 'SELECT LeisureCheck WHERE pass_id = '. $oPass->GetKey();			
				$oSet_Checks = new \DBObjectSet(\DBObjectSearch::FromOQL($sOQL));
							
				// Now we should retrieve all checks for this pass
				$iAmountChecks = 0;
				while($oCheck = $oSet_Checks->Fetch()) {
					$iAmountChecks += $oCheck->Get('value');
				}
				
				$sOQL = 'SELECT LeisurePassCategory WHERE id = '. $oPass->Get('category_id');			
				$oPassCategorySet = new \DBObjectSet(DBObjectSearch::FromOQL($sOQL));
						
				// There should be one category
				while($oPassCategory = $oPassCategorySet->Fetch()) {
					$iMaxAmount = $oPassCategory->Get('value');
				}
				
				// Amount of checks should NOT be higher than the value of the pass
				if($iAmountChecks > $iMaxAmount) {
					return Array( 
						\Dict::S('Errors/LeisurePass/ValueOfChecksTooHigh')." ( ". $iAmountChecks . " / " . $iMaxAmount . " )"
					);
				}
			
			}
			
			// New object? ( id = 0 )
			elseif((Int)$oPass->GetKey() == 0) {
				
				// In any case: there should only be one pass per year per person
				// (originally written before iTop 2.6.0 where this kind of duplicate could not be prevented without code)
				$sOQL = "SELECT LeisurePass WHERE person_id = ". $oPass->Get('person_id')." AND DATE_FORMAT(created, '%Y') = ".date('Y');			
				$oPassesThisYear = new \DBObjectSet(\DBObjectSearch::FromOQL($sOQL));
				
				if( $oPassesThisYear->Count() > 0 ) {
					return Array( 
						\Dict::S('Errors/LeisurePass/OnePassPerYear')." ( ". $iAmount . " / " . $iMaxAmount . " )"
					);		
				
				}
				
			}
			
		}
		
		
		elseif($oObject instanceof LeisureCheck) {
			
			// user should not be able to create a new pass ( $oObject->Value ) if the TOTAL Value of previous checks AND this new one is bigger than the category of the pass
			$oCheck = $oObject; // to make it easier to read the code
			
			// Get all existing checks (could include this one if it's being modified)
			$sOQL = 'SELECT LeisureCheck WHERE pass_id = '. $oCheck->Get('pass_id') . ' AND id != ' . (Int)$oCheck->GetKey();			
			$oSet_RelatedChecks = new \DBObjectSet(DBObjectSearch::FromOQL($sOQL));
			
			// Get pass
			$sOQL = 'SELECT LeisurePass WHERE id = '. $oCheck->Get('pass_id');			
			$oSet_Passes = new \DBObjectSet(DBObjectSearch::FromOQL($sOQL));

			$iAmount = 0;
			
			// This should be 1 pass
			while($oPassCurrent = $oSet_Passes->Fetch()) { 
				$oPass = $oPassCurrent;
			}
			
			// Get total value of all checks related to this pass (excluding current check)
			while($oExistingCheck = $oSet_RelatedChecks->Fetch()) {
				$iAmount += $oExistingCheck->Get('value');
			}
			
			// What's the new total amount?
			$iNewTotalAmount = $iAmount + $oCheck->Get('value');
			
			// Get value of pass
			$sOQL = 'SELECT LeisurePassCategory WHERE id = '. $oPass->Get('category_id');			
			$oSet_PassCategories = new \DBObjectSet(\DBObjectSearch::FromOQL($sOQL));
					
			// There will only be one
			while($oPassCategory = $oSet_PassCategories->Fetch()) {
				$iMaxAmount = $oPassCategory->Get('value');
			}
			
			// Amount of all checks including new value of the current one must be smaller than the total value (category) of the pass
			if($iNewTotalAmount > $iMaxAmount) {
				return Array( 
					\Dict::S('Errors/LeisurePass/ValueOfChecksTooHigh')." ( ". $iNewTotalAmount. " / " . $iMaxAmount  . " )"
				);
			}
			
		}
		
		// No errors		
		return Array();
		
	}
	
	
	
		/**
	 *	Invoked to determine whether an object has been modified in memory
	 *
	 *	The GUI calls this verb to determine the message that will be displayed to the end-user.
	 *	Anyhow, this API can be called in other contexts such as the CSV import tool.
	 *	
	 * If the extension returns false, then the framework will perform the usual evaluation.
	 * Otherwise, the answer is definitively "yes, the object has changed".	 	 	 
	 *	 
	 * @param DBObject $oObject The target object
	 * @return boolean True if something has changed for the target object
	 */	
	public function OnIsModified($oObject) {
		return false;
	}
 

	/**
	 *	Invoked to determine whether an object can be deleted from the database
	 *	
	 * The GUI calls this verb and stops the deletion process if any issue is reported.
	 * 	 
	 * Please not that it is not possible to cascade deletion by this mean: only stopper issues can be handled. 	 
	 * 
	 * @param DBObject $oObject The target object
	 * @return string[] A list of errors message. An error message is made of one line and it can be displayed to the end-user.
	 */	
	public function OnCheckToDelete($oObject) {
		return Array();
		
	}

	/**
	 *	Invoked when an object is updated into the database
	 *	
	 * The method is called right <b>after</b> the object has been written to the database.
	 * 
	 * @param DBObject $oObject The target object
	 * @param CMDBChange|null $oChange A change context. Since 2.0 it is fine to ignore it, as the framework does maintain this information once for all the changes made within the current page
	 * @return void
	 */	
	public function OnDBUpdate($oObject, $oChange = null)  {
		return;
	}

	/**
	 *	Invoked when an object is created into the database
	 *	
	 * The method is called right <b>after</b> the object has been written to the database.
	 * 
	 * @param DBObject $oObject The target object
	 * @param CMDBChange|null $oChange A change context. Since 2.0 it is fine to ignore it, as the framework does maintain this information once for all the changes made within the current page
	 * @return void
	 */	
	public function OnDBInsert($oObject, $oChange = null) {
		return;
	}

	/**
	 *	Invoked when an object is deleted from the database
	 *	
	 * The method is called right <b>before</b> the object will be deleted from the database.
	 * 
	 * @param DBObject $oObject The target object
	 * @param CMDBChange|null $oChange A change context. Since 2.0 it is fine to ignore it, as the framework does maintain this information once for all the changes made within the current page
	 * @return void
	 */	
	public function OnDBDelete($oObject, $oChange = null) {
		return;
	}
	
	 
	
	
	
}


